import { Component, EventEmitter, forwardRef, Inject, Input, Output, ViewChild, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { MatAutocompleteTrigger } from '@angular/material/autocomplete';
import { fromEvent, Subject } from 'rxjs';
import { debounceTime, startWith, takeUntil } from 'rxjs/operators';
import { MatSelectCountryLangToken } from './tokens';
/**
 * @author Anthony Nahas
 * @since 11.19
 * @version 2.1.0
 */
export class MatSelectCountryComponent {
    constructor(i18n) {
        this.i18n = i18n;
        this.placeHolder = 'Select country';
        // tslint:disable-next-line: no-output-on-prefix
        this.onCountrySelected = new EventEmitter();
        this.debounceTime = 300;
        this.filterString = '';
        this.modelChanged = new Subject();
        this.propagateChange = (_) => { };
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.propagateChange(this._value);
    }
    ngOnInit() {
        if (!this.countries) {
            // console.log('lang', this.i18n);
            this.loadingDB = true;
            this._importLang(this.i18n)
                .then((res) => {
                // console.log('countries', this.countries);
            }).catch((err) => console.error('Error: ' + err))
                .finally(() => this.loadingDB = false);
        }
        this.subscription = this.modelChanged
            .pipe(startWith(''), debounceTime(this.debounceTime))
            .subscribe((value) => {
            this.filterString = value;
            this._filter(value);
        });
    }
    ngOnChanges(changes) {
        // console.log('changes', changes);
        if (changes.country) {
            if (changes.country.currentValue) {
                const newValue = changes.country.currentValue.toUpperCase();
                this.value = this.countries.find((country) => country.name.toUpperCase() === newValue ||
                    country.alpha2Code === newValue ||
                    country.alpha3Code === newValue ||
                    country.numericCode === newValue);
            }
            else {
                this.value = undefined;
            }
        }
    }
    onBlur() {
        if (this.value && this.nullable) {
            this.value = null;
            this.onCountrySelected.emit(null);
        }
    }
    onOptionsSelected($event) {
        this.value = this.countries.find((country) => country.name === $event.option.value);
        this.onCountrySelected.emit(this.value);
    }
    writeValue(obj) {
        if (obj) {
            this.value = obj;
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        // throw new Error('Method not implemented.');
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    autocompleteScroll() {
        if (this.itemsLoadSize) {
            setTimeout(() => {
                if (this.statesAutocompleteRef &&
                    this.autocompleteTrigger &&
                    this.statesAutocompleteRef.panel) {
                    fromEvent(this.statesAutocompleteRef.panel.nativeElement, 'scroll')
                        .pipe(takeUntil(this.autocompleteTrigger.panelClosingActions))
                        .subscribe(() => {
                        const scrollTop = this.statesAutocompleteRef.panel.nativeElement
                            .scrollTop;
                        const scrollHeight = this.statesAutocompleteRef.panel
                            .nativeElement.scrollHeight;
                        const elementHeight = this.statesAutocompleteRef.panel
                            .nativeElement.clientHeight;
                        const atBottom = scrollHeight === scrollTop + elementHeight;
                        if (atBottom) {
                            // fetch more data if not filtered
                            if (this.filterString === '') {
                                const fromIndex = this.filteredOptions.length;
                                const toIndex = +this.filteredOptions.length + +this.itemsLoadSize;
                                this.filteredOptions = [
                                    ...this.filteredOptions,
                                    ...this.countries.slice(fromIndex, toIndex),
                                ];
                            }
                        }
                    });
                }
            });
        }
    }
    inputChanged(value) {
        this.modelChanged.next(value);
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    _importLang(i18n) {
        switch (i18n) {
            case 'de':
                return import('./i18n/de').then(result => result.COUNTRIES_DB_DE).then(y => {
                    this.countries = y;
                    return y;
                });
            case 'it':
                return import('./i18n/it').then(result => result.COUNTRIES_DB_IT).then(y => {
                    this.countries = y;
                    return y;
                });
            case 'es':
                return import('./i18n/es').then(result => result.COUNTRIES_DB_ES).then(y => {
                    this.countries = y;
                    return y;
                });
            case 'fr':
                return import('./i18n/fr').then(result => result.COUNTRIES_DB_FR).then(y => {
                    this.countries = y;
                    return y;
                });
            default:
                // console.log('running with default');
                return import('./i18n/en').then(result => result.COUNTRIES_DB).then(y => {
                    this.countries = y;
                    return y;
                });
        }
    }
    _filter(value) {
        const filterValue = value.toLowerCase();
        // if not filtered, fetch reduced array
        if (this.itemsLoadSize && filterValue === '') {
            this.filteredOptions = this.countries.slice(0, this.itemsLoadSize);
        }
        else {
            this.filteredOptions = this.countries.filter((option) => option.name.toLowerCase().includes(filterValue) ||
                option.alpha2Code.toLowerCase().includes(filterValue) ||
                option.alpha3Code.toLowerCase().includes(filterValue));
        }
    }
}
MatSelectCountryComponent.decorators = [
    { type: Component, args: [{
                selector: 'mat-select-country',
                template: "<mat-form-field [appearance]=\"appearance\">\n    <mat-label *ngIf=\"label\">{{label}}</mat-label>\n    <mat-icon *ngIf=\"this.value\" [svgIcon]=\"this.value?.alpha2Code?.toLowerCase()\" class=\"mr-12 s-20 secondary-text\"\n              matSuffix></mat-icon>\n    <input (blur)=\"onBlur()\" (input)=\"inputChanged($event?.target?.value)\"\n           [class]=\"class\"\n           [matAutocomplete]=\"this.countryAutocomplete\"\n           [placeholder]=\"this.placeHolder\"\n           [readonly]=\"this.readonly\"\n           [value]=\"this.value?.name\"\n           [required]=\"this.required\"\n           [disabled]=\"this.disabled || this.loadingDB\"\n           aria-label=\"country\"\n           matInput type=\"text\">\n    <mat-progress-bar *ngIf=\"this.loadingDB || this.loading\" mode=\"buffer\"></mat-progress-bar>\n    <mat-autocomplete #countryAutocomplete=\"matAutocomplete\" (opened)=\"autocompleteScroll()\"\n                      (optionSelected)=\"onOptionsSelected($event)\">\n        <mat-option *ngFor=\"let country of filteredOptions\" [value]=\"country?.name\">\n            <mat-icon [svgIcon]=\"country?.alpha2Code?.toLowerCase()\"></mat-icon>\n            <small>{{ [country?.name, country?.alpha3Code] | joinStrings }}</small>\n        </mat-option>\n    </mat-autocomplete>\n</mat-form-field>\n\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => MatSelectCountryComponent),
                        multi: true,
                    },
                ],
                styles: [""]
            },] }
];
MatSelectCountryComponent.ctorParameters = () => [
    { type: String, decorators: [{ type: Inject, args: [forwardRef(() => MatSelectCountryLangToken),] }] }
];
MatSelectCountryComponent.propDecorators = {
    appearance: [{ type: Input }],
    countries: [{ type: Input }],
    label: [{ type: Input }],
    placeHolder: [{ type: Input }],
    required: [{ type: Input }],
    disabled: [{ type: Input }],
    nullable: [{ type: Input }],
    readonly: [{ type: Input }],
    class: [{ type: Input }],
    itemsLoadSize: [{ type: Input }],
    loading: [{ type: Input }],
    statesAutocompleteRef: [{ type: ViewChild, args: ['countryAutocomplete',] }],
    autocompleteTrigger: [{ type: ViewChild, args: [MatAutocompleteTrigger,] }],
    onCountrySelected: [{ type: Output }],
    value: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LXNlbGVjdC1jb3VudHJ5LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItbWF0ZXJpYWwtZXh0ZW5zaW9ucy9zZWxlY3QtY291bnRyeS9zcmMvbGliL21hdC1zZWxlY3QtY291bnRyeS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxZQUFZLEVBQ1osVUFBVSxFQUNWLE1BQU0sRUFDTixLQUFLLEVBSUwsTUFBTSxFQUVOLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFpRCxzQkFBc0IsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRXZILE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUN4RCxPQUFPLEVBQUUsWUFBWSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFZckQ7Ozs7R0FJRztBQWFILE1BQU0sT0FBTyx5QkFBeUI7SUErQnBDLFlBQXdFLElBQVk7UUFBWixTQUFJLEdBQUosSUFBSSxDQUFRO1FBMUIzRSxnQkFBVyxHQUFHLGdCQUFnQixDQUFDO1FBWXhDLGdEQUFnRDtRQUN0QyxzQkFBaUIsR0FBMEIsSUFBSSxZQUFZLEVBQVcsQ0FBQztRQUtqRixpQkFBWSxHQUFHLEdBQUcsQ0FBQztRQUNuQixpQkFBWSxHQUFHLEVBQUUsQ0FBQztRQUNWLGlCQUFZLEdBQW9CLElBQUksT0FBTyxFQUFVLENBQUM7UUFtQjlELG9CQUFlLEdBQUcsQ0FBQyxDQUFNLEVBQUUsRUFBRSxHQUFFLENBQUMsQ0FBQztJQVpqQyxDQUFDO0lBRUQsSUFBSSxLQUFLO1FBQ1As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QUFFLEVBQUUsQ0FDbEIsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDO2dCQUMvQyxNQUFNLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUM7Z0JBQ3JELE1BQU0sQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUN4RCxDQUFDO1NBQ0g7SUFDSCxDQUFDOzs7WUEzTkYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxvQkFBb0I7Z0JBQzlCLDJ6Q0FBZ0Q7Z0JBRWhELFNBQVMsRUFBRTtvQkFDVDt3QkFDRSxPQUFPLEVBQUUsaUJBQWlCO3dCQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLHlCQUF5QixDQUFDO3dCQUN4RCxLQUFLLEVBQUUsSUFBSTtxQkFDWjtpQkFDRjs7YUFDRjs7O3lDQWdDYyxNQUFNLFNBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLHlCQUF5QixDQUFDOzs7eUJBN0I5RCxLQUFLO3dCQUNMLEtBQUs7b0JBQ0wsS0FBSzswQkFDTCxLQUFLO3VCQUNMLEtBQUs7dUJBQ0wsS0FBSzt1QkFDTCxLQUFLO3VCQUNMLEtBQUs7b0JBQ0wsS0FBSzs0QkFDTCxLQUFLO3NCQUNMLEtBQUs7b0NBRUwsU0FBUyxTQUFDLHFCQUFxQjtrQ0FDL0IsU0FBUyxTQUFDLHNCQUFzQjtnQ0FHaEMsTUFBTTtvQkFvQk4sS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBvbmVudCxcbiAgRXZlbnRFbWl0dGVyLFxuICBmb3J3YXJkUmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFNpbXBsZUNoYW5nZXMsXG4gIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBNYXRBdXRvY29tcGxldGUsIE1hdEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQsIE1hdEF1dG9jb21wbGV0ZVRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9hdXRvY29tcGxldGUnO1xuaW1wb3J0IHsgTWF0Rm9ybUZpZWxkQXBwZWFyYW5jZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2Zvcm0tZmllbGQnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0LCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgc3RhcnRXaXRoLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBNYXRTZWxlY3RDb3VudHJ5TGFuZ1Rva2VuIH0gZnJvbSAnLi90b2tlbnMnO1xuXG4vKipcbiAqIENvdW50cnkgaW50ZXJmYWNlIElTTyAzMTY2XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ291bnRyeSB7XG4gIG5hbWU6IHN0cmluZztcbiAgYWxwaGEyQ29kZTogc3RyaW5nO1xuICBhbHBoYTNDb2RlOiBzdHJpbmc7XG4gIG51bWVyaWNDb2RlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogQGF1dGhvciBBbnRob255IE5haGFzXG4gKiBAc2luY2UgMTEuMTlcbiAqIEB2ZXJzaW9uIDIuMS4wXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21hdC1zZWxlY3QtY291bnRyeScsXG4gIHRlbXBsYXRlVXJsOiAnbWF0LXNlbGVjdC1jb3VudHJ5LmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ21hdC1zZWxlY3QtY291bnRyeS5jb21wb25lbnQuc2NzcyddLFxuICBwcm92aWRlcnM6IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1hdFNlbGVjdENvdW50cnlDb21wb25lbnQpLFxuICAgICAgbXVsdGk6IHRydWUsXG4gICAgfSxcbiAgXSxcbn0pXG5leHBvcnQgY2xhc3MgTWF0U2VsZWN0Q291bnRyeUNvbXBvbmVudFxuICBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgQElucHV0KCkgYXBwZWFyYW5jZTogTWF0Rm9ybUZpZWxkQXBwZWFyYW5jZTtcbiAgQElucHV0KCkgY291bnRyaWVzOiBDb3VudHJ5W107XG4gIEBJbnB1dCgpIGxhYmVsOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHBsYWNlSG9sZGVyID0gJ1NlbGVjdCBjb3VudHJ5JztcbiAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG4gIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuO1xuICBASW5wdXQoKSBudWxsYWJsZTogYm9vbGVhbjtcbiAgQElucHV0KCkgcmVhZG9ubHk6IGJvb2xlYW47XG4gIEBJbnB1dCgpIGNsYXNzOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGl0ZW1zTG9hZFNpemU6IG51bWJlcjtcbiAgQElucHV0KCkgbG9hZGluZzogYm9vbGVhbjtcblxuICBAVmlld0NoaWxkKCdjb3VudHJ5QXV0b2NvbXBsZXRlJykgc3RhdGVzQXV0b2NvbXBsZXRlUmVmOiBNYXRBdXRvY29tcGxldGU7XG4gIEBWaWV3Q2hpbGQoTWF0QXV0b2NvbXBsZXRlVHJpZ2dlcikgYXV0b2NvbXBsZXRlVHJpZ2dlcjogTWF0QXV0b2NvbXBsZXRlVHJpZ2dlcjtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLW91dHB1dC1vbi1wcmVmaXhcbiAgQE91dHB1dCgpIG9uQ291bnRyeVNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8Q291bnRyeT4gPSBuZXcgRXZlbnRFbWl0dGVyPENvdW50cnk+KCk7XG5cbiAgZmlsdGVyZWRPcHRpb25zOiBDb3VudHJ5W107XG4gIGRiOiBDb3VudHJ5W107XG4gIGxvYWRpbmdEQjogYm9vbGVhbjtcbiAgZGVib3VuY2VUaW1lID0gMzAwO1xuICBmaWx0ZXJTdHJpbmcgPSAnJztcbiAgcHJpdmF0ZSBtb2RlbENoYW5nZWQ6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IHZhcmlhYmxlLW5hbWVcbiAgcHJpdmF0ZSBfdmFsdWU6IENvdW50cnk7XG5cbiAgY29uc3RydWN0b3IoQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE1hdFNlbGVjdENvdW50cnlMYW5nVG9rZW4pKSBwdWJsaWMgaTE4bjogc3RyaW5nKSB7XG4gIH1cblxuICBnZXQgdmFsdWUoKTogQ291bnRyeSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG5cbiAgQElucHV0KClcbiAgc2V0IHZhbHVlKHZhbHVlOiBDb3VudHJ5KSB7XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZSh0aGlzLl92YWx1ZSk7XG4gIH1cblxuICBwcm9wYWdhdGVDaGFuZ2UgPSAoXzogYW55KSA9PiB7fTtcblxuICBuZ09uSW5pdCgpIHtcbiAgICBpZiAoIXRoaXMuY291bnRyaWVzKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnbGFuZycsIHRoaXMuaTE4bik7XG4gICAgICB0aGlzLmxvYWRpbmdEQiA9IHRydWU7XG4gICAgICB0aGlzLl9pbXBvcnRMYW5nKHRoaXMuaTE4bilcbiAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb3VudHJpZXMnLCB0aGlzLmNvdW50cmllcyk7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpID0+IGNvbnNvbGUuZXJyb3IoJ0Vycm9yOiAnICsgZXJyKSlcbiAgICAgICAgLmZpbmFsbHkoKCkgPT4gdGhpcy5sb2FkaW5nREIgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLm1vZGVsQ2hhbmdlZFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN0YXJ0V2l0aCgnJyksXG4gICAgICAgIGRlYm91bmNlVGltZSh0aGlzLmRlYm91bmNlVGltZSlcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RyaW5nID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2ZpbHRlcih2YWx1ZSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnY2hhbmdlcycsIGNoYW5nZXMpO1xuICAgIGlmIChjaGFuZ2VzLmNvdW50cnkpIHtcbiAgICAgIGlmIChjaGFuZ2VzLmNvdW50cnkuY3VycmVudFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY2hhbmdlcy5jb3VudHJ5LmN1cnJlbnRWYWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5jb3VudHJpZXMuZmluZChcbiAgICAgICAgICAoY291bnRyeSkgPT5cbiAgICAgICAgICAgIGNvdW50cnkubmFtZS50b1VwcGVyQ2FzZSgpID09PSBuZXdWYWx1ZSB8fFxuICAgICAgICAgICAgY291bnRyeS5hbHBoYTJDb2RlID09PSBuZXdWYWx1ZSB8fFxuICAgICAgICAgICAgY291bnRyeS5hbHBoYTNDb2RlID09PSBuZXdWYWx1ZSB8fFxuICAgICAgICAgICAgY291bnRyeS5udW1lcmljQ29kZSA9PT0gbmV3VmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25CbHVyKCkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmIHRoaXMubnVsbGFibGUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5vbkNvdW50cnlTZWxlY3RlZC5lbWl0KG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIG9uT3B0aW9uc1NlbGVjdGVkKCRldmVudDogTWF0QXV0b2NvbXBsZXRlU2VsZWN0ZWRFdmVudCkge1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLmNvdW50cmllcy5maW5kKFxuICAgICAgKGNvdW50cnkpID0+IGNvdW50cnkubmFtZSA9PT0gJGV2ZW50Lm9wdGlvbi52YWx1ZVxuICAgICk7XG4gICAgdGhpcy5vbkNvdW50cnlTZWxlY3RlZC5lbWl0KHRoaXMudmFsdWUpO1xuICB9XG5cbiAgd3JpdGVWYWx1ZShvYmo6IGFueSk6IHZvaWQge1xuICAgIGlmIChvYmopIHtcbiAgICAgIHRoaXMudmFsdWUgPSBvYmo7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgfVxuXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gIH1cblxuICBzZXREaXNhYmxlZFN0YXRlPyhpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gIH1cblxuICBhdXRvY29tcGxldGVTY3JvbGwoKSB7XG4gICAgaWYgKHRoaXMuaXRlbXNMb2FkU2l6ZSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLnN0YXRlc0F1dG9jb21wbGV0ZVJlZiAmJlxuICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlVHJpZ2dlciAmJlxuICAgICAgICAgIHRoaXMuc3RhdGVzQXV0b2NvbXBsZXRlUmVmLnBhbmVsXG4gICAgICAgICkge1xuICAgICAgICAgIGZyb21FdmVudCh0aGlzLnN0YXRlc0F1dG9jb21wbGV0ZVJlZi5wYW5lbC5uYXRpdmVFbGVtZW50LCAnc2Nyb2xsJylcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmF1dG9jb21wbGV0ZVRyaWdnZXIucGFuZWxDbG9zaW5nQWN0aW9ucykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5zdGF0ZXNBdXRvY29tcGxldGVSZWYucGFuZWwubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgIC5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHRoaXMuc3RhdGVzQXV0b2NvbXBsZXRlUmVmLnBhbmVsXG4gICAgICAgICAgICAgICAgLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50SGVpZ2h0ID0gdGhpcy5zdGF0ZXNBdXRvY29tcGxldGVSZWYucGFuZWxcbiAgICAgICAgICAgICAgICAubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgIGNvbnN0IGF0Qm90dG9tID0gc2Nyb2xsSGVpZ2h0ID09PSBzY3JvbGxUb3AgKyBlbGVtZW50SGVpZ2h0O1xuICAgICAgICAgICAgICBpZiAoYXRCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAvLyBmZXRjaCBtb3JlIGRhdGEgaWYgbm90IGZpbHRlcmVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyU3RyaW5nID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbUluZGV4ID0gdGhpcy5maWx0ZXJlZE9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9JbmRleDogbnVtYmVyID1cbiAgICAgICAgICAgICAgICAgICAgK3RoaXMuZmlsdGVyZWRPcHRpb25zLmxlbmd0aCArICt0aGlzLml0ZW1zTG9hZFNpemU7XG4gICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkT3B0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5maWx0ZXJlZE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuY291bnRyaWVzLnNsaWNlKGZyb21JbmRleCwgdG9JbmRleCksXG4gICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlucHV0Q2hhbmdlZCh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5tb2RlbENoYW5nZWQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaW1wb3J0TGFuZyhpMThuOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIHN3aXRjaCAoaTE4bikge1xuICAgICAgY2FzZSAnZGUnOlxuICAgICAgICByZXR1cm4gaW1wb3J0KCcuL2kxOG4vZGUnKS50aGVuKHJlc3VsdCA9PiByZXN1bHQuQ09VTlRSSUVTX0RCX0RFKS50aGVuKHkgPT4ge1xuICAgICAgICAgIHRoaXMuY291bnRyaWVzID0geTtcbiAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlICdpdCc6XG4gICAgICAgIHJldHVybiBpbXBvcnQoJy4vaTE4bi9pdCcpLnRoZW4ocmVzdWx0ID0+IHJlc3VsdC5DT1VOVFJJRVNfREJfSVQpLnRoZW4oeSA9PiB7XG4gICAgICAgICAgdGhpcy5jb3VudHJpZXMgPSB5O1xuICAgICAgICAgIHJldHVybiB5O1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgJ2VzJzpcbiAgICAgICAgcmV0dXJuIGltcG9ydCgnLi9pMThuL2VzJykudGhlbihyZXN1bHQgPT4gcmVzdWx0LkNPVU5UUklFU19EQl9FUykudGhlbih5ID0+IHtcbiAgICAgICAgICB0aGlzLmNvdW50cmllcyA9IHk7XG4gICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAnZnInOlxuICAgICAgICByZXR1cm4gaW1wb3J0KCcuL2kxOG4vZnInKS50aGVuKHJlc3VsdCA9PiByZXN1bHQuQ09VTlRSSUVTX0RCX0ZSKS50aGVuKHkgPT4ge1xuICAgICAgICAgIHRoaXMuY291bnRyaWVzID0geTtcbiAgICAgICAgICByZXR1cm4geTtcbiAgICAgICAgfSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBjb25zb2xlLmxvZygncnVubmluZyB3aXRoIGRlZmF1bHQnKTtcbiAgICAgICAgcmV0dXJuIGltcG9ydCgnLi9pMThuL2VuJykudGhlbihyZXN1bHQgPT4gcmVzdWx0LkNPVU5UUklFU19EQikudGhlbih5ID0+IHtcbiAgICAgICAgICB0aGlzLmNvdW50cmllcyA9IHk7XG4gICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2ZpbHRlcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgZmlsdGVyVmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gaWYgbm90IGZpbHRlcmVkLCBmZXRjaCByZWR1Y2VkIGFycmF5XG4gICAgaWYgKHRoaXMuaXRlbXNMb2FkU2l6ZSAmJiBmaWx0ZXJWYWx1ZSA9PT0gJycpIHtcbiAgICAgIHRoaXMuZmlsdGVyZWRPcHRpb25zID0gdGhpcy5jb3VudHJpZXMuc2xpY2UoMCwgdGhpcy5pdGVtc0xvYWRTaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maWx0ZXJlZE9wdGlvbnMgPSB0aGlzLmNvdW50cmllcy5maWx0ZXIoXG4gICAgICAgIChvcHRpb246IENvdW50cnkpID0+XG4gICAgICAgICAgb3B0aW9uLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhmaWx0ZXJWYWx1ZSkgfHxcbiAgICAgICAgICBvcHRpb24uYWxwaGEyQ29kZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGZpbHRlclZhbHVlKSB8fFxuICAgICAgICAgIG9wdGlvbi5hbHBoYTNDb2RlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVyVmFsdWUpXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl19