import { __decorate, __param } from "tslib";
import { Directive, ElementRef, HostListener, Optional, Self } from '@angular/core';
import { CreditCard } from '../credit-card';
import { NgControl } from '@angular/forms';
let CvcFormatDirective = class CvcFormatDirective {
    constructor(el, control) {
        this.el = el;
        this.control = control;
        this.target = this.el.nativeElement;
    }
    /**
     * Updates the value to target element, or FormControl if exists.
     * @param value New input value.
     */
    updateValue(value) {
        if (this.control) {
            this.control.control.setValue(value);
        }
        else {
            this.target.value = value;
        }
    }
    onKeypress(e) {
        if (!CreditCard.restrictNumeric(e) && !CreditCard.restrictCvc(e.which, this.target)) {
            e.preventDefault();
        }
    }
    reformatCvc() {
        const val = CreditCard.replaceFullWidthChars(this.target.value)
            .replace(/\D/g, '')
            .slice(0, 4);
        const oldVal = this.target.value;
        if (val !== oldVal) {
            this.target.selectionStart = this.target.selectionEnd = CreditCard.safeVal(val, this.target, (safeVal => {
                this.updateValue(safeVal);
            }));
        }
    }
};
CvcFormatDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgControl, decorators: [{ type: Self }, { type: Optional }] }
];
__decorate([
    HostListener('keypress', ['$event'])
], CvcFormatDirective.prototype, "onKeypress", null);
__decorate([
    HostListener('paste'),
    HostListener('change'),
    HostListener('input')
], CvcFormatDirective.prototype, "reformatCvc", null);
CvcFormatDirective = __decorate([
    Directive({
        selector: '[ccCVC]',
    }),
    __param(1, Self()), __param(1, Optional())
], CvcFormatDirective);
export { CvcFormatDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3ZjLWZvcm1hdC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLWNjLWxpYnJhcnkvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9jdmMtZm9ybWF0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEYsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUszQyxJQUFhLGtCQUFrQixHQUEvQixNQUFhLGtCQUFrQjtJQUc3QixZQUNVLEVBQWMsRUFDTSxPQUFrQjtRQUR0QyxPQUFFLEdBQUYsRUFBRSxDQUFZO1FBQ00sWUFBTyxHQUFQLE9BQU8sQ0FBVztRQUU5QyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7O09BR0c7SUFDSyxXQUFXLENBQUMsS0FBYTtRQUMvQixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3RDO2FBQU07WUFDTCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7U0FDM0I7SUFDSCxDQUFDO0lBR00sVUFBVSxDQUFDLENBQWdCO1FBQ2hDLElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNuRixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7U0FDcEI7SUFDSCxDQUFDO0lBS00sV0FBVztRQUNoQixNQUFNLEdBQUcsR0FBRyxVQUFVLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7YUFDNUQsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7YUFDbEIsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNmLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ2pDLElBQUksR0FBRyxLQUFLLE1BQU0sRUFBRTtZQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksR0FBRyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ3RHLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNMO0lBQ0gsQ0FBQztDQUNGLENBQUE7O1lBdkNlLFVBQVU7WUFDZSxTQUFTLHVCQUE3QyxJQUFJLFlBQUksUUFBUTs7QUFrQm5CO0lBREMsWUFBWSxDQUFDLFVBQVUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29EQUtwQztBQUtEO0lBSEMsWUFBWSxDQUFDLE9BQU8sQ0FBQztJQUNyQixZQUFZLENBQUMsUUFBUSxDQUFDO0lBQ3RCLFlBQVksQ0FBQyxPQUFPLENBQUM7cURBV3JCO0FBMUNVLGtCQUFrQjtJQUg5QixTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsU0FBUztLQUNwQixDQUFDO0lBTUcsV0FBQSxJQUFJLEVBQUUsQ0FBQSxFQUFFLFdBQUEsUUFBUSxFQUFFLENBQUE7R0FMVixrQkFBa0IsQ0EyQzlCO1NBM0NZLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPcHRpb25hbCwgU2VsZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ3JlZGl0Q2FyZCB9IGZyb20gJy4uL2NyZWRpdC1jYXJkJztcbmltcG9ydCB7IE5nQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2NjQ1ZDXScsXG59KVxuZXhwb3J0IGNsYXNzIEN2Y0Zvcm1hdERpcmVjdGl2ZSB7XG4gIHByaXZhdGUgdGFyZ2V0OiBIVE1MSW5wdXRFbGVtZW50O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEVsZW1lbnRSZWYsXG4gICAgQFNlbGYoKSBAT3B0aW9uYWwoKSBwcml2YXRlIGNvbnRyb2w6IE5nQ29udHJvbCxcbiAgKSB7XG4gICAgdGhpcy50YXJnZXQgPSB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmFsdWUgdG8gdGFyZ2V0IGVsZW1lbnQsIG9yIEZvcm1Db250cm9sIGlmIGV4aXN0cy5cbiAgICogQHBhcmFtIHZhbHVlIE5ldyBpbnB1dCB2YWx1ZS5cbiAgICovXG4gIHByaXZhdGUgdXBkYXRlVmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcbiAgICAgIHRoaXMuY29udHJvbC5jb250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXQudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdrZXlwcmVzcycsIFsnJGV2ZW50J10pXG4gIHB1YmxpYyBvbktleXByZXNzKGU6IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoIUNyZWRpdENhcmQucmVzdHJpY3ROdW1lcmljKGUpICYmICFDcmVkaXRDYXJkLnJlc3RyaWN0Q3ZjKGUud2hpY2gsIHRoaXMudGFyZ2V0KSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ3Bhc3RlJylcbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJylcbiAgQEhvc3RMaXN0ZW5lcignaW5wdXQnKVxuICBwdWJsaWMgcmVmb3JtYXRDdmMoKSB7XG4gICAgY29uc3QgdmFsID0gQ3JlZGl0Q2FyZC5yZXBsYWNlRnVsbFdpZHRoQ2hhcnModGhpcy50YXJnZXQudmFsdWUpXG4gICAgICAucmVwbGFjZSgvXFxEL2csICcnKVxuICAgICAgLnNsaWNlKDAsIDQpO1xuICAgIGNvbnN0IG9sZFZhbCA9IHRoaXMudGFyZ2V0LnZhbHVlO1xuICAgIGlmICh2YWwgIT09IG9sZFZhbCkge1xuICAgICAgdGhpcy50YXJnZXQuc2VsZWN0aW9uU3RhcnQgPSB0aGlzLnRhcmdldC5zZWxlY3Rpb25FbmQgPSBDcmVkaXRDYXJkLnNhZmVWYWwodmFsLCB0aGlzLnRhcmdldCwgKHNhZmVWYWwgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHNhZmVWYWwpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufVxuIl19